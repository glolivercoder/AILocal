#!/usr/bin/env python3
"""
Teste e Exemplo de Uso do Sistema RAG Moderno
"""

import os
import sys
from pathlib import Path
import logging
from typing import Dict, Any

# Adicionar diret√≥rio atual ao path
sys.path.append(str(Path(__file__).parent))

from rag_system_modern import (
    ModernRAGSystem, RAGConfig, VectorDBType, EmbeddingModel,
    create_modern_rag_system, create_chromadb_rag_system, create_qdrant_rag_system
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def test_system_dependencies():
    """Testa depend√™ncias do sistema"""
    print("üîç Testando depend√™ncias do sistema...")
    
    dependencies = {
        "LangChain": False,
        "ChromaDB": False,
        "Qdrant": False,
        "SentenceTransformers": False,
        "NumPy": False,
        "Requests": False
    }
    
    try:
        import langchain
        dependencies["LangChain"] = True
    except ImportError:
        pass
    
    try:
        import chromadb
        dependencies["ChromaDB"] = True
    except ImportError:
        pass
    
    try:
        import qdrant_client
        dependencies["Qdrant"] = True
    except ImportError:
        pass
    
    try:
        import sentence_transformers
        dependencies["SentenceTransformers"] = True
    except ImportError:
        pass
    
    try:
        import numpy
        dependencies["NumPy"] = True
    except ImportError:
        pass
    
    try:
        import requests
        dependencies["Requests"] = True
    except ImportError:
        pass
    
    print("\nüìã Status das depend√™ncias:")
    for dep, available in dependencies.items():
        status = "‚úÖ" if available else "‚ùå"
        print(f"  {status} {dep}")
    
    return dependencies

def create_test_documents():
    """Cria documentos de teste"""
    test_dir = Path("test_documents")
    test_dir.mkdir(exist_ok=True)
    
    # Documento sobre desenvolvimento de apps
    app_dev_content = """
# Desenvolvimento de Aplica√ß√µes M√≥veis

## Introdu√ß√£o
O desenvolvimento de aplica√ß√µes m√≥veis √© uma √°rea em constante evolu√ß√£o, com novas tecnologias e frameworks surgindo regularmente.

## Tecnologias Principais

### React Native
React Native √© um framework que permite desenvolver aplica√ß√µes nativas para iOS e Android usando JavaScript e React.

**Vantagens:**
- C√≥digo compartilhado entre plataformas
- Performance pr√≥xima ao nativo
- Grande comunidade
- Hot reload para desenvolvimento r√°pido

**Desvantagens:**
- Algumas limita√ß√µes para funcionalidades muito espec√≠ficas
- Depend√™ncia de bibliotecas nativas para certas funcionalidades

### Flutter
Flutter √© o framework do Google para desenvolvimento multiplataforma usando Dart.

**Vantagens:**
- Performance excelente
- UI consistente entre plataformas
- Hot reload
- Crescimento r√°pido da comunidade

**Desvantagens:**
- Linguagem Dart menos popular
- Tamanho do app pode ser maior

### Desenvolvimento Nativo

#### iOS (Swift/Objective-C)
- Performance m√°xima
- Acesso completo √†s APIs do sistema
- Melhor integra√ß√£o com o ecossistema Apple

#### Android (Kotlin/Java)
- Performance m√°xima
- Acesso completo √†s APIs do Android
- Flexibilidade total de customiza√ß√£o

## Arquitetura de Apps

### MVVM (Model-View-ViewModel)
Padr√£o recomendado para aplica√ß√µes modernas, especialmente com frameworks como React Native e Flutter.

### Clean Architecture
Arquitetura que promove separa√ß√£o de responsabilidades e testabilidade.

## Banco de Dados

### SQLite
Banco local padr√£o para aplica√ß√µes m√≥veis.

### Realm
Banco de dados objeto-relacional com boa performance.

### Firebase Firestore
Banco NoSQL em nuvem com sincroniza√ß√£o em tempo real.

## Seguran√ßa

### Autentica√ß√£o
- OAuth 2.0
- JWT tokens
- Biometria (Touch ID, Face ID, Fingerprint)

### Criptografia
- HTTPS obrigat√≥rio
- Criptografia de dados sens√≠veis
- Keychain/Keystore para armazenamento seguro

### Prote√ß√£o de APIs
- Rate limiting
- Valida√ß√£o de entrada
- Sanitiza√ß√£o de dados

## Deploy

### iOS
- App Store Connect
- TestFlight para beta testing
- Certificados e provisioning profiles

### Android
- Google Play Console
- Play Console Internal Testing
- Assinatura de apps

## Monetiza√ß√£o

### Modelos de Neg√≥cio
- Freemium
- Assinatura (SaaS)
- Compras in-app
- Publicidade
- Pagamento √∫nico

### Ferramentas de Analytics
- Google Analytics
- Firebase Analytics
- Mixpanel
- Amplitude
"""
    
    # Documento sobre SaaS
    saas_content = """
# Desenvolvimento de SaaS (Software as a Service)

## Conceitos Fundamentais

SaaS √© um modelo de distribui√ß√£o de software onde as aplica√ß√µes s√£o hospedadas por um provedor de servi√ßos e disponibilizadas aos clientes atrav√©s da internet.

## Arquitetura SaaS

### Multi-tenancy
Arquitetura onde uma √∫nica inst√¢ncia da aplica√ß√£o serve m√∫ltiplos clientes (tenants).

**Tipos:**
1. **Single-tenant**: Cada cliente tem sua pr√≥pria inst√¢ncia
2. **Multi-tenant compartilhado**: Todos os clientes compartilham a mesma inst√¢ncia
3. **Multi-tenant isolado**: Dados separados por tenant na mesma inst√¢ncia

### Microservi√ßos
Arquitetura que divide a aplica√ß√£o em servi√ßos pequenos e independentes.

**Benef√≠cios:**
- Escalabilidade independente
- Tecnologias diversas
- Desenvolvimento paralelo
- Resili√™ncia

## Stack Tecnol√≥gico

### Backend
- **Node.js**: JavaScript no servidor
- **Python**: Django, FastAPI, Flask
- **Java**: Spring Boot
- **C#**: .NET Core
- **Go**: Performance e concorr√™ncia

### Frontend
- **React**: Biblioteca JavaScript
- **Vue.js**: Framework progressivo
- **Angular**: Framework completo
- **Svelte**: Compilador moderno

### Banco de Dados
- **PostgreSQL**: Relacional robusto
- **MongoDB**: NoSQL flex√≠vel
- **Redis**: Cache e sess√µes
- **Elasticsearch**: Busca e analytics

### Infraestrutura
- **AWS**: Amazon Web Services
- **Google Cloud**: GCP
- **Azure**: Microsoft Cloud
- **Docker**: Containeriza√ß√£o
- **Kubernetes**: Orquestra√ß√£o

## Seguran√ßa

### Autentica√ß√£o e Autoriza√ß√£o
- **OAuth 2.0**: Padr√£o de autoriza√ß√£o
- **OpenID Connect**: Camada de identidade
- **SAML**: Security Assertion Markup Language
- **Multi-factor Authentication (MFA)**

### Prote√ß√£o de Dados
- **GDPR**: Regulamenta√ß√£o europeia
- **LGPD**: Lei brasileira de prote√ß√£o de dados
- **Criptografia**: Em tr√¢nsito e em repouso
- **Backup**: Estrat√©gias de recupera√ß√£o

## M√©tricas e KPIs

### M√©tricas de Neg√≥cio
- **MRR**: Monthly Recurring Revenue
- **ARR**: Annual Recurring Revenue
- **Churn Rate**: Taxa de cancelamento
- **LTV**: Lifetime Value
- **CAC**: Customer Acquisition Cost

### M√©tricas T√©cnicas
- **Uptime**: Disponibilidade do servi√ßo
- **Response Time**: Tempo de resposta
- **Throughput**: Requisi√ß√µes por segundo
- **Error Rate**: Taxa de erro

## Pricing e Monetiza√ß√£o

### Modelos de Pre√ßo
- **Freemium**: Vers√£o gratuita limitada
- **Tiered**: Planos escalonados
- **Per-user**: Por usu√°rio
- **Usage-based**: Baseado no uso
- **Enterprise**: Pre√ßo customizado

## Deploy e DevOps

### CI/CD
- **GitHub Actions**: Automa√ß√£o GitHub
- **GitLab CI**: Pipeline integrado
- **Jenkins**: Servidor de automa√ß√£o
- **CircleCI**: Integra√ß√£o cont√≠nua

### Monitoramento
- **Prometheus**: M√©tricas
- **Grafana**: Visualiza√ß√£o
- **ELK Stack**: Logs
- **Sentry**: Error tracking

### Escalabilidade
- **Load Balancing**: Distribui√ß√£o de carga
- **Auto Scaling**: Escala autom√°tica
- **CDN**: Content Delivery Network
- **Caching**: Estrat√©gias de cache
"""
    
    # Documento sobre MVP
    mvp_content = """
# MVP (Minimum Viable Product) - Guia Completo

## Defini√ß√£o

MVP √© a vers√£o mais simples de um produto que pode ser lan√ßada com o m√≠nimo de recursos necess√°rios para validar uma hip√≥tese de neg√≥cio.

## Princ√≠pios do MVP

### Build-Measure-Learn
Ciclo fundamental do desenvolvimento lean:
1. **Build**: Construir o m√≠nimo necess√°rio
2. **Measure**: Medir resultados e feedback
3. **Learn**: Aprender e iterar

### Valida√ß√£o de Hip√≥teses
- **Problem-Solution Fit**: O problema existe?
- **Product-Market Fit**: A solu√ß√£o resolve o problema?
- **Business Model Fit**: O modelo de neg√≥cio √© vi√°vel?

## Tipos de MVP

### Landing Page MVP
P√°gina simples para validar interesse e capturar leads.

**Elementos essenciais:**
- Proposta de valor clara
- Call-to-action
- Formul√°rio de cadastro
- Analytics para medir convers√£o

### Concierge MVP
Servi√ßo manual que simula a experi√™ncia automatizada.

**Vantagens:**
- Valida√ß√£o r√°pida
- Feedback direto
- Baixo custo inicial

### Wizard of Oz MVP
Interface automatizada com processos manuais por tr√°s.

### Prototype MVP
Vers√£o funcional b√°sica com features essenciais.

## Metodologias de Valida√ß√£o

### Lean Startup
Metodologia focada em aprendizado validado e itera√ß√£o r√°pida.

### Design Thinking
Abordagem centrada no usu√°rio para inova√ß√£o.

**Etapas:**
1. **Empatizar**: Entender o usu√°rio
2. **Definir**: Definir o problema
3. **Idear**: Gerar solu√ß√µes
4. **Prototipar**: Criar prot√≥tipos
5. **Testar**: Validar com usu√°rios

### Jobs to be Done
Framework para entender motiva√ß√µes dos clientes.

## M√©tricas de Valida√ß√£o

### M√©tricas de Engajamento
- **DAU/MAU**: Daily/Monthly Active Users
- **Session Duration**: Tempo de sess√£o
- **Page Views**: Visualiza√ß√µes de p√°gina
- **Bounce Rate**: Taxa de rejei√ß√£o

### M√©tricas de Convers√£o
- **Conversion Rate**: Taxa de convers√£o
- **Funnel Analysis**: An√°lise de funil
- **A/B Testing**: Testes comparativos

### M√©tricas de Reten√ß√£o
- **Retention Rate**: Taxa de reten√ß√£o
- **Cohort Analysis**: An√°lise de coorte
- **Churn Rate**: Taxa de abandono

## Ferramentas para MVP

### No-Code/Low-Code
- **Bubble**: Desenvolvimento visual
- **Webflow**: Design e desenvolvimento
- **Airtable**: Banco de dados visual
- **Zapier**: Automa√ß√£o de processos

### Prototipagem
- **Figma**: Design de interfaces
- **InVision**: Prototipagem interativa
- **Marvel**: Prototipagem simples
- **Framer**: Prototipagem avan√ßada

### Analytics
- **Google Analytics**: Web analytics
- **Mixpanel**: Event tracking
- **Hotjar**: Heatmaps e grava√ß√µes
- **Amplitude**: Product analytics

## Estrat√©gias de Lan√ßamento

### Soft Launch
Lan√ßamento limitado para grupo restrito de usu√°rios.

### Beta Testing
Teste com usu√°rios reais antes do lan√ßamento oficial.

### Product Hunt
Plataforma para lan√ßamento de produtos tech.

### Growth Hacking
T√©cnicas de crescimento r√°pido e escal√°vel.

## Erros Comuns

### Over-engineering
Construir mais do que o necess√°rio para valida√ß√£o.

### Vanity Metrics
Focar em m√©tricas que n√£o indicam sucesso real.

### Ignorar Feedback
N√£o incorporar aprendizados dos usu√°rios.

### Perfeccionismo
Esperar muito tempo para lan√ßar.

## Pr√≥ximos Passos

### Ap√≥s Valida√ß√£o
1. **Scale**: Escalar o produto validado
2. **Optimize**: Otimizar performance e UX
3. **Expand**: Adicionar novas features
4. **Monetize**: Implementar modelo de receita

### Pivoting
Quando mudar dire√ß√£o baseado nos aprendizados:
- **Customer Segment Pivot**: Mudar p√∫blico-alvo
- **Problem Pivot**: Mudar problema a resolver
- **Solution Pivot**: Mudar solu√ß√£o
- **Business Model Pivot**: Mudar modelo de neg√≥cio
"""
    
    # Salvar documentos
    documents = {
        "desenvolvimento_apps.md": app_dev_content,
        "desenvolvimento_saas.md": saas_content,
        "mvp_guia_completo.md": mvp_content
    }
    
    for filename, content in documents.items():
        file_path = test_dir / filename
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
    
    print(f"üìÑ Documentos de teste criados em: {test_dir}")
    return test_dir

def test_chromadb_system():
    """Testa sistema com ChromaDB"""
    print("\nüß™ Testando Sistema RAG com ChromaDB...")
    
    try:
        # Criar sistema
        rag = create_chromadb_rag_system(
            data_dir="test_rag_chromadb",
            embedding_model=EmbeddingModel.MINILM  # Modelo menor para teste
        )
        
        print("‚úÖ Sistema ChromaDB criado com sucesso")
        
        # Status do sistema
        status = rag.get_system_status()
        print(f"üìä Status: {status}")
        
        # Criar documentos de teste
        test_dir = create_test_documents()
        
        # Adicionar documentos
        for doc_file in test_dir.glob("*.md"):
            success = rag.add_document(doc_file)
            if success:
                print(f"‚úÖ Documento adicionado: {doc_file.name}")
            else:
                print(f"‚ùå Falha ao adicionar: {doc_file.name}")
        
        # Testar buscas
        test_queries = [
            "Como desenvolver aplica√ß√µes React Native?",
            "Qual a diferen√ßa entre SaaS e aplica√ß√µes tradicionais?",
            "Como validar um MVP?",
            "Quais s√£o as melhores pr√°ticas de seguran√ßa para apps m√≥veis?",
            "Como implementar multi-tenancy em SaaS?"
        ]
        
        print("\nüîç Testando buscas:")
        for query in test_queries:
            print(f"\nüìù Query: {query}")
            results = rag.search(query, top_k=3)
            
            if results:
                for i, result in enumerate(results, 1):
                    print(f"  {i}. [{result['source']}] Score: {result['similarity_score']:.3f}")
                    print(f"     {result['text'][:100]}...")
            else:
                print("  ‚ùå Nenhum resultado encontrado")
        
        # Testar contexto
        print("\nüìã Testando gera√ß√£o de contexto:")
        context = rag.get_context_for_query("Como desenvolver um MVP para SaaS?")
        print(f"Contexto gerado ({len(context)} caracteres):")
        print(context[:500] + "..." if len(context) > 500 else context)
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erro no teste ChromaDB: {e}")
        return False

def test_simple_system():
    """Testa sistema simples sem depend√™ncias avan√ßadas"""
    print("\nüß™ Testando Sistema RAG Simples...")
    
    try:
        # Configura√ß√£o m√≠nima
        config = RAGConfig(
            data_dir="test_rag_simple",
            vector_db_type=VectorDBType.CHROMADB,
            embedding_model=EmbeddingModel.MINILM,
            chunk_size=500,
            chunk_overlap=50
        )
        
        rag = ModernRAGSystem(config)
        print("‚úÖ Sistema simples criado")
        
        # Status
        status = rag.get_system_status()
        print(f"üìä Status: {status['system_version']} - {status['documents_count']} docs")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erro no teste simples: {e}")
        return False

def run_comprehensive_test():
    """Executa teste abrangente do sistema"""
    print("üöÄ Iniciando Teste Abrangente do Sistema RAG Moderno")
    print("=" * 60)
    
    # Testar depend√™ncias
    deps = test_system_dependencies()
    
    # Determinar quais testes executar
    tests_to_run = []
    
    if deps["ChromaDB"] and deps["SentenceTransformers"]:
        tests_to_run.append(("ChromaDB", test_chromadb_system))
    
    if deps["NumPy"] and deps["Requests"]:
        tests_to_run.append(("Simples", test_simple_system))
    
    if not tests_to_run:
        print("\n‚ùå Nenhum teste pode ser executado - depend√™ncias insuficientes")
        print("\nüì¶ Para instalar depend√™ncias:")
        print("pip install -r requirements_rag_modern.txt")
        return False
    
    # Executar testes
    results = {}
    for test_name, test_func in tests_to_run:
        print(f"\n{'='*20} TESTE {test_name.upper()} {'='*20}")
        results[test_name] = test_func()
    
    # Resumo
    print("\n" + "="*60)
    print("üìä RESUMO DOS TESTES")
    print("="*60)
    
    for test_name, success in results.items():
        status = "‚úÖ PASSOU" if success else "‚ùå FALHOU"
        print(f"  {test_name}: {status}")
    
    overall_success = all(results.values())
    print(f"\nüéØ Resultado Geral: {'‚úÖ SUCESSO' if overall_success else '‚ùå FALHA'}")
    
    if overall_success:
        print("\nüéâ Sistema RAG Moderno est√° funcionando corretamente!")
        print("\nüìö Pr√≥ximos passos:")
        print("  1. Adicione seus pr√≥prios documentos")
        print("  2. Configure APIs de LLM (OpenRouter, OpenAI, etc.)")
        print("  3. Integre com sua aplica√ß√£o")
        print("  4. Configure monitoramento e logs")
    else:
        print("\nüîß Algumas funcionalidades precisam de ajustes")
        print("\nüí° Sugest√µes:")
        print("  1. Verifique instala√ß√£o das depend√™ncias")
        print("  2. Configure vari√°veis de ambiente")
        print("  3. Verifique conectividade de rede")
    
    return overall_success

if __name__ == "__main__":
    run_comprehensive_test()